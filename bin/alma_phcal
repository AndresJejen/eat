#!/usr/bin/env python
#
# Use ALMA to reference phase-cal phases and delay offsets
# 2017-11-22 Chi-kwan Chan (move from pipeline to EAT)
# 2017-12-28 CKC major update to simplify pipelining

from __future__ import print_function

import datetime, pwd, os, sys
import argparse
import string

import pandas as pd
import numpy  as np

from eat.io   import hops, util
from eat.hops import util as hu

#==============================================================================
# Helper functions

def unwrap(phi):
    """Unwrap an array of angles to avoid artificial jumps due to branching
    """
    for i in np.arange(len(phi)-1)+1:
        if   phi[i] - phi[i-1] >  180: phi[i:] -= 360
        elif phi[i] - phi[i-1] < -180: phi[i:] += 360
    return phi

def offset(phi):
    """Offset an array of angles (in degree) to the principle branch
    """
    while True:
        m = np.mean(phi)
        if   m >  180: phi -= 360
        elif m < -180: phi += 360
        else         : break
    return phi

def get_param(file, diff=True, pol=None,
              baseline=True, source=False, nchan=False, head=False):
    """Read an alist file and prepare phases phase-cal

    Read an alist file, apply filter to select the userful rows, and
    then access the corel (per-channel) phases for performing
    phase-cal.
    """
    a = util.noauto(hops.read_alist(file))

    # Apply row filtering
    if pol is None:
        a = a[(a.polarization == 'LL')|
              (a.polarization == 'RR')]
    else:
        a = a[(a.polarization == "{}{}".format(pol, pol).upper())]

    a = a[a.baseline.str.contains("A")] # must contain ALMA

    if head: # for testing
        a = a.iloc[0:10]

    a = a.reset_index(drop=True)
    util.add_path(a)

    # Decide which columns to return
    cols = ['baseline' if baseline else 'path']
    if source:
        cols += ['source']
    if nchan:
        a['nchan']= 32
        cols += ['nchan']
    cols += ['quality', 'snr', 'resid_phas']

    # Access corel (per-channel) phases
    chans  = list(string.ascii_letters[:32])
    phases = np.zeros((len(a), len(chans)), dtype=np.float32)
    for i, p in a.path.iteritems():
        if diff:
            deg2rad = np.pi / 180.0
            t = a.resid_phas[i] * deg2rad
            v = hu.pop210(p) * np.exp(-1j * t)
        else:
            v = hu.pop210(p)
        phases[i,:] = offset(unwrap(np.angle(v, deg=True)))

    # Construct and return final Pandas DataFrame
    return pd.concat([a[cols], pd.DataFrame(phases, columns=chans)], axis=1)

def qfit(y1, y2, y3):
    a  =       y1
    b  = (-3.0*y1 + 4.0*y2 - y3) / 2.0
    c  = (     y1 - 2.0*y2 + y3) / 2.0
    return a, b, c

def mkplot(baselines, phases, slopes, target):
    import matplotlib.pyplot as plt
    import matplotlib.cm     as cm # not best practice, but avoid extra
                                   # library when no graph is specified
    cs = cm.rainbow(np.linspace(0,1,len(baselines)))
    d  = np.array([-0.5,0.5])
    x  = np.arange(32)
    for i, b in baselines.iteritems():
        y = phases[i,:]
        m = slopes[i,:]
        plt.scatter(x, y, color=cs[i], label=b)
        for j in np.arange(32):
            plt.plot(x[j]+d, y[j]+d*m[j], color=cs[i])
    plt.legend()
    if "." in target:
        plt.savefig(target)
    else:
        plt.show()

def output(s, a, t):
    out = pd.DataFrame(data=a)
    out.insert(0, 'label', s)
    out.to_csv(t, index=False, header=False, sep=" ", float_format="%.9g")

def output_cf(sites, pol, phases, delays, target):
    with open(target, "w") as f:
        p = "" if pol is None else "_"+pol
        for i, s in sites.iteritems():
            f.write("""if station {}
  pc_phases{}  abcdefghijklmnopqrstuvwxyzABCDEF""".format(s, p))
            for j in range(32):
                f.write(" {:.6f}".format(phases[i,j]))
            f.write("""
  delay_offs{} abcdefghijklmnopqrstuvwxyzABCDEF""".format(p))
            for j in range(32):
                f.write(" {:.6f}".format(delays[i,j]))
            f.write("\n\n")

#==============================================================================
# Main code
#------------------------------------------------------------------------------
# Logging
statline = "[{}] {}@{}:{}$ {}".format(
    datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
    pwd.getpwuid(os.getuid())[0], os.uname()[1], os.getcwd(),
    ' '.join(sys.argv))

#------------------------------------------------------------------------------
# Argument parsing and read input file
parser = argparse.ArgumentParser(
    description="Estimate phase-cal phases and delay offsets")
parser.add_argument('filename',
                    help='alist file')
parser.add_argument('-o', '--outfile', default=[sys.stdout], nargs='+',
                    help='output csv filename')
parser.add_argument('-c', '--controlcodes', default=False, action='store_true',
                    help='construct control codes rather than csv table')
parser.add_argument('-p', '--polarization', default=None,
                    help="select polarization")
parser.add_argument('-g', '--graph', default=None,
                    help="graphic output")
args = parser.parse_args()

if len(args.outfile) > 2:
    print("At most 2 output files are supported")
    exit(1)
elif args.controlcodes and len(args.outfile) != 1:
    print("Only 1 output file is supported when \"--controlcodes\" is set")
    exit(1)

#------------------------------------------------------------------------------
# Get data and perform phase cal
chans = list(string.ascii_letters[:32])
param = get_param(args.filename, pol=args.polarization, head=True)
phcal = param.groupby('baseline')[chans].mean()

# Pull out baselines and phases, use one-side and mid-point
# methods to esimate slopes
baselines = pd.Series(phcal.index.values)
phases    = phcal.values
slopes    = np.concatenate((np.reshape(phases[:, 1 ] - phases[:,  0], (-1,1)),
                                0.5 * (phases[:, 2:] - phases[:,:-2]),
                            np.reshape(phases[:,-1 ] - phases[:, -2], (-1,1))),
                           axis=1)

# Extrapolation for last channel
a, b, c = qfit(phases[:,-4], phases[:,-3], phases[:,-2])
phases[:,-1] = a + 3.0*b + 9.0*c # == a + b x +   c x**2 with x == 3
slopes[:,-1] =         b + 6.0*c # ==     b   + 2 c x    with x == 3

# Apply fitted slope (instead of one-side derivative) to edge channels
slopes[:,-2] = b + 4.0*c # == b   + 2 c x    with x == 2
a, b, c = qfit(phases[:,0], phases[:,1], phases[:,2])
slopes[:, 0] = b         # == b   + 2 c x    with x == 0

# Convert slopes to delay offsets
d_nu   = 58.59375e6 # hard wire separation between channels
delays = 1e9 * (slopes / 360.0) / d_nu # in nanosecond

#------------------------------------------------------------------------------
# Outputs
if args.graph is not None:
    mkplot(baselines, phases, slopes, args.graph)

if args.controlcodes:
    output_cf(baselines.str[1], args.polarization, -phases, -delays,
              args.outfile[0])
else:
    output(baselines.str[1], -slopes, args.outfile[0])
    if len(args.outfile) > 1:
        output(baselines.str[1], -delays, args.outfile[1])
